From 712414404caf221fd6812f677f27a713c8c2fb8e Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Mon, 5 Oct 2015 21:56:16 -0400
Subject: [PATCH] Create tbaa_gcframe and decorate all stores and loads from
 the GC frame with it. Close #13301

---
 src/codegen.cpp | 43 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 43 insertions(+)

diff --git a/src/codegen.cpp b/src/codegen.cpp
index fcc2f3b..a373d7d 100644
--- a/src/codegen.cpp
+++ b/src/codegen.cpp
@@ -280,6 +280,7 @@ static MDNode *tbaa_sveclen;           // The len in a jl_svec_t
 static MDNode *tbaa_func;           // A jl_function_t
 static MDNode *tbaa_datatype;       // A jl_datatype_t
 static MDNode *tbaa_const;          // Memory that is immutable by the time LLVM can see it
+static MDNode *tbaa_gcframe;        // A GC frame
 
 // Basic DITypes
 #ifdef LLVM37
@@ -3792,6 +3793,46 @@ static void clear_gc_frame(jl_gcinfo_t *gc)
     il.erase(gc->last_gcframe_inst);
 }
 
+// Decorate all stores and loads of derived pointers from the GC frame to have
+// tbaa_gcframe
+static void
+tbaa_decorate_gcframe(std::set<Instruction*> &visited, Instruction *inst)
+{
+    if (visited.find(inst) != visited.end())
+        return;
+    visited.insert(inst);
+#ifdef LLVM35
+    Value::user_iterator I = inst->user_begin(), E = inst->user_end();
+#else
+    Value::use_iterator I = inst->use_begin(), E = inst->use_end();
+#endif
+    for (;I != E;++I) {
+        Instruction *user = dyn_cast<Instruction>(*I);
+        if (!user) {
+            continue;
+        } else if (isa<GetElementPtrInst>(user)) {
+            if (__likely(user->getOperand(0) == inst)) {
+                tbaa_decorate_gcframe(visited, user);
+            }
+        } else if (isa<StoreInst>(user)) {
+            if (user->getOperand(1) == inst) {
+                tbaa_decorate(tbaa_gcframe, user);
+            }
+        } else if (isa<LoadInst>(user)) {
+            tbaa_decorate(tbaa_gcframe, user);
+        } else if (isa<BitCastInst>(user)) {
+            tbaa_decorate_gcframe(visited, user);
+        }
+    }
+}
+
+static void
+tbaa_decorate_gcframe(jl_codectx_t *ctx)
+{
+    std::set<Instruction*> visited;
+    tbaa_decorate_gcframe(visited, ctx->gc.gcframe);
+}
+
 static void
 emit_gcpops(jl_codectx_t *ctx)
 {
@@ -3838,6 +3879,7 @@ static void finalize_gc_frame(jl_codectx_t *ctx)
         builder.CreateStore(V_null, argTempi);
     }
     emit_gcpops(ctx);
+    tbaa_decorate_gcframe(ctx);
 }
 
 // here argt does not include the leading function type argument
@@ -5223,6 +5265,7 @@ static void init_julia_llvm_env(Module *m)
     tbaa_func = tbaa_make_child("jtbaa_func",tbaa_value);
     tbaa_datatype = tbaa_make_child("jtbaa_datatype",tbaa_value);
     tbaa_const = tbaa_make_child("jtbaa_const",tbaa_root,true);
+    tbaa_gcframe = tbaa_make_child("jtbaa_gcframe",tbaa_root);
 
     // every variable or function mapped in this function must be
     // exported from libjulia, to support static compilation
-- 
2.6.4

