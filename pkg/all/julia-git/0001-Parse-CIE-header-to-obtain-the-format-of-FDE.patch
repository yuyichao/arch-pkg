From f37a267ed9cb9733b82c70cbb02cb62d96a9b409 Mon Sep 17 00:00:00 2001
From: Yichao Yu <yyc1992@gmail.com>
Date: Tue, 9 Feb 2016 20:14:39 -0500
Subject: [PATCH] Parse CIE header to obtain the format of FDE

---
 src/debuginfo.cpp | 216 +++++++++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 196 insertions(+), 20 deletions(-)

diff --git a/src/debuginfo.cpp b/src/debuginfo.cpp
index 0344eec..53cc5bd 100644
--- a/src/debuginfo.cpp
+++ b/src/debuginfo.cpp
@@ -1183,13 +1183,50 @@ struct unw_table_entry
     int32_t fde_offset;
 };
 
-// static uint8_t *consume_leb128(uint8_t *Addr, size_t Size)
-// {
-//     uint8_t *P = Addr;
-//     while ((*P >> 7) != 0 && P < Addr + Size)
-//         ++P;
-//     return P;
-// }
+static const uint8_t *consume_leb128(const uint8_t *Addr, size_t Size)
+{
+    const uint8_t *P = Addr;
+    while ((*P >> 7) != 0 && P < Addr + Size)
+        ++P;
+    return P + 1;
+}
+
+template<typename T> static inline T parse_leb128(const uint8_t *&Addr);
+
+template<> uint64_t parse_leb128<uint64_t>(const uint8_t *&Addr)
+{
+    uint64_t v = 0;
+    for (int i = 0;i < 10;i++) {
+        Addr++;
+        uint8_t a = *Addr;
+        v |= uint64_t(a & 0x7f) << (i * 7);
+        if ((a & 0x80) == 0)
+            return v;
+    }
+    assert(0 && "LEB128 encoding too long");
+    return v;
+}
+
+template<> int64_t parse_leb128<int64_t>(const uint8_t *&Addr)
+{
+    uint64_t v = 0;
+    for (int i = 0;i < 10;i++) {
+        Addr++;
+        uint8_t a = *Addr;
+        v |= uint64_t(a & 0x7f) << (i * 7);
+        if ((a & 0x80) == 0) {
+            if (a & 0x40) {
+                int valid_bits = (i + 1) * 7;
+                if (valid_bits < 64) {
+                    v |= -(uint64_t(1) << valid_bits);
+                }
+            }
+            return int64_t(v);
+        }
+    }
+    assert(0 && "LEB128 encoding too long");
+    return v;
+}
 
 template <typename U, typename T>
 static U safe_trunc(T t)
@@ -1199,6 +1236,89 @@ static U safe_trunc(T t)
     return static_cast<U>(t);
 }
 
+enum DW_EH_PE : uint8_t {
+    DW_EH_PE_absptr = 0x00, /* An absolute pointer. The size is determined by
+                             * whether this is a 32-bit or 64-bit address space,
+                             * and will be 32 or 64 bits */
+    DW_EH_PE_omit = 0xff, // The value is omitted
+    DW_EH_PE_uleb128 = 0x01, // The value is an unsigned LEB128
+    DW_EH_PE_udata2 = 0x02,
+    DW_EH_PE_udata4 = 0x03,
+    DW_EH_PE_udata8 = 0x04, /* The value is stored as unsigned data with the
+                             * specified number of bytes. */
+    DW_EH_PE_signed = 0x08, /* A signed number. The size is determined by
+                             * whether this is a 32-bit or 64-bit address space */
+    DW_EH_PE_sleb128 = 0x09, /* A signed LEB128. */
+    DW_EH_PE_sdata2 = 0x0a,
+    DW_EH_PE_sdata4 = 0x0b,
+    DW_EH_PE_sdata8 = 0x0c, /* The value is stored as signed data with the
+                             * specified number of bytes. */
+
+    // In addition the above basic encodings, there are modifiers.
+
+    DW_EH_PE_pcrel = 0x10, // Value is PC relative.
+    DW_EH_PE_textrel = 0x20, // Value is text relative.
+    DW_EH_PE_datarel = 0x30, // Value is data relative.
+    DW_EH_PE_funcrel = 0x40, // Value is relative to start of function.
+    DW_EH_PE_aligned = 0x50, /* Value is aligned: padding bytes are inserted as
+                              * required to make value be naturally aligned. */
+    DW_EH_PE_indirect = 0x80 /* This is actually the address of the real value. */
+};
+
+static DW_EH_PE parseCIE(const uint8_t *Addr, size_t Size)
+{
+    // The first entry in a eh_frame should be a CIE frame.
+    uint32_t cie_size = *(const uint32_t*)Addr;
+    const uint8_t *cie_addr = Addr + 4;
+    const uint8_t *p = cie_addr;
+    assert(cie_addr + cie_size < Addr + Size);
+    // Check this is an CIE record (4 bytes)
+    assert(*(const uint32_t*)cie_addr == 0);
+    p += 4;
+    // Check CIE version (1 byte)
+    uint8_t cie_version = *p;
+    assert(cie_version == 1 || cie_version == 3);
+    p++;
+    // Augmentation String (NUL terminate)
+    const char *augmentation = (const char*)p;
+    size_t augmentation_len = strlen(augmentation);
+    // Assume there's no EH Data field, which exist when the augmentation
+    // string has "eh" in it.
+    p += augmentation_len + 1;
+    // code alignment factor (1 byte) should always be 1
+    assert(*p == 1);
+    p++;
+    // data alignment factor (LEB128)
+    assert(cie_addr + cie_size >= p);
+    p = consume_leb128(p, cie_addr + cie_size - p);
+    // return address register
+    if (cie_version == 1) {
+        p++;
+    }
+    else {
+        p = consume_leb128(p, cie_addr + cie_size - p);
+    }
+    // Now it's the augmentation data. which may have the information we
+    // are interested in...
+    for (const char *augp = augmentation;;augp++) {
+        switch (*augp) {
+        case 'z':
+            p = consume_leb128(p, cie_addr + cie_size - p);
+            break;
+        case 'L':
+        case 'P':
+            p++;
+            break;
+        case 'R':
+            // .... the only one we care about ....
+            return static_cast<DW_EH_PE>(*p);
+        default:
+            continue;
+        }
+    }
+    return DW_EH_PE_absptr;
+}
+
 void RTDyldMemoryManagerUnix::registerEHFrames(uint8_t *Addr,
                                                uint64_t LoadAddr,
                                                size_t Size)
@@ -1208,6 +1328,11 @@ void RTDyldMemoryManagerUnix::registerEHFrames(uint8_t *Addr,
     // Linux uses setjmp/longjmp exception handling on ARM.
     __register_frame(Addr);
 #endif
+    // http://www.airs.com/blog/archives/460
+    // Parse the CIE entry, in particular, we are interested in how
+    // the address/sizes are encoded.
+    DW_EH_PE encoding = parseCIE(Addr, Size);
+
     // Our unwinder
     unw_dyn_info_t *di = new unw_dyn_info_t;
     // In a shared library, this is set to the address of the PLT.
@@ -1215,7 +1340,7 @@ void RTDyldMemoryManagerUnix::registerEHFrames(uint8_t *Addr,
     // not seem to be used on our supported architectures.
     di->gp = 0;
     // I'm not a great fan of the naming of this constant, but it means the
-    // right thing, which is a table of FDEs and ips. The remote is unimportant
+    // right thing, which is a table of FDEs and ips.
     di->format = UNW_INFO_FORMAT_IP_OFFSET;
     di->u.ti.name_ptr = 0;
     di->u.ti.segbase = (unw_word_t)Addr;
@@ -1230,29 +1355,80 @@ void RTDyldMemoryManagerUnix::registerEHFrames(uint8_t *Addr,
     // While we're at it, also record the start_ip and size,
     // which we fill in the table
     unw_table_entry *table = new unw_table_entry[nentries];
+    std::vector<uintptr_t> start_ips(nentries);
     size_t cur_entry = 0;
     processFDEs((char*)Addr, Size, [&](const char *Entry) {
-            const uintptr_t *EntryPtr = ((const uintptr_t*)Entry) + 1;
-            uintptr_t start = *EntryPtr + (uintptr_t)EntryPtr; // Assume pcrel | sabs8
-            EntryPtr++;
-            uintptr_t size = *EntryPtr;
+            // Skip Length (4bytes) and CIE offset (4bytes)
+            const uint8_t *EntryPtr = (const uint8_t*)(Entry + 8);
+            uintptr_t start = 0;
+            uintptr_t size = 0;
+            if (encoding == DW_EH_PE_absptr || encoding == DW_EH_PE_omit) {
+                start = *(const uintptr_t*)EntryPtr;
+                size = *(const uintptr_t*)(EntryPtr + sizeof(void*));
+            }
+            else {
+                // Only support pcrel for now...
+                assert(encoding & 0xf0 == 0x10);
+                switch (encoding & 0xf) {
+                case DW_EH_PE_uleb128:
+                    start = uintptr_t((uintptr_t)EntryPtr +
+                                      parse_leb128<uint64_t>(EntryPtr));
+                    size = uintptr_t(parse_leb128<uint64_t>(EntryPtr));
+                    break;
+                case DW_EH_PE_udata2:
+                    start = (uintptr_t)EntryPtr + ((const uint16_t*)EntryPtr)[0];
+                    size = ((const uint16_t*)EntryPtr)[1];
+                    break;
+                case DW_EH_PE_udata4:
+                    start = (uintptr_t)EntryPtr + ((const uint32_t*)EntryPtr)[0];
+                    size = ((const uint32_t*)EntryPtr)[1];
+                    break;
+                case DW_EH_PE_udata8:
+                    start = uintptr_t((uintptr_t)EntryPtr +
+                                      ((const uint64_t*)EntryPtr)[0]);
+                    size = uintptr_t(((const uint64_t*)EntryPtr)[1]);
+                    break;
+                case DW_EH_PE_signed:
+                    start = (uintptr_t)EntryPtr + ((const intptr_t*)EntryPtr)[0];
+                    size = ((const intptr_t*)EntryPtr)[1];
+                    break;
+                case DW_EH_PE_sleb128:
+                    start = uintptr_t((uintptr_t)EntryPtr +
+                                      parse_leb128<int64_t>(EntryPtr));
+                    size = uintptr_t(parse_leb128<int64_t>(EntryPtr));
+                    break;
+                case DW_EH_PE_sdata2:
+                    start = (uintptr_t)EntryPtr + ((const int16_t*)EntryPtr)[0];
+                    size = ((const int16_t*)EntryPtr)[1];
+                    break;
+                case DW_EH_PE_sdata4:
+                    start = (uintptr_t)EntryPtr + ((const int32_t*)EntryPtr)[0];
+                    size = ((const int32_t*)EntryPtr)[1];
+                    break;
+                case DW_EH_PE_sdata8:
+                    start = uintptr_t((uintptr_t)EntryPtr +
+                                      ((const int64_t*)EntryPtr)[0]);
+                    size = uintptr_t(((const int64_t*)EntryPtr)[1]);
+                    break;
+                default:
+                    assert(0 && "Invalid FDE format.");
+                    break;
+                }
+            }
 
             if (start < start_ip)
                 start_ip = start;
             if (end_ip < (start + size))
                 end_ip = start+size;
-        });
-
-    processFDEs((char*)Addr, Size, [&](const char *Entry) {
-            const uintptr_t *EntryPtr = ((const uintptr_t*)Entry) + 1;
-            uintptr_t start = *EntryPtr + (uintptr_t)EntryPtr; // Assume pcrel | sabs8
-            table[cur_entry].start_ip_offset =
-                safe_trunc<int32_t>((intptr_t)start - (intptr_t)start_ip);
             table[cur_entry].fde_offset =
                 safe_trunc<int32_t>((intptr_t)Entry - (intptr_t)Addr);
+            start_ips[cur_entry] = start;
             cur_entry++;
         });
-
+    for (size_t i = 0;i < nentries;i++) {
+        table[i].start_ip_offset =
+            safe_trunc<int32_t>((intptr_t)start_ips[i] - (intptr_t)start_ip);
+    }
     assert(end_ip != 0);
 
     di->u.ti.table_len = nentries;
-- 
2.6.4

