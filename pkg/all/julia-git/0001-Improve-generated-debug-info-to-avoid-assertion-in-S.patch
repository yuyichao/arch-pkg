From 16c31aff012b1f38a244a28aa5865e0c2cf31a2d Mon Sep 17 00:00:00 2001
From: Keno Fischer <kfischer@college.harvard.edu>
Date: Sun, 25 Oct 2015 23:23:47 +0000
Subject: [PATCH] Improve generated debug info to avoid assertion in SROA

---
 src/cgutils.cpp | 34 +++++++++++++++++++++++++++++++++-
 src/codegen.cpp | 13 ++++++-------
 2 files changed, 39 insertions(+), 8 deletions(-)

diff --git a/src/cgutils.cpp b/src/cgutils.cpp
index 0d68928..05dc656 100644
--- a/src/cgutils.cpp
+++ b/src/cgutils.cpp
@@ -350,8 +350,13 @@ static DIType *julia_type_to_di(jl_value_t *jt, DIBuilder *dbuilder, bool isboxe
 static DIType julia_type_to_di(jl_value_t *jt, DIBuilder *dbuilder, bool isboxed = false)
 #endif
 {
-    if (jl_is_abstracttype(jt) || !jl_is_datatype(jt) || !jl_isbits(jt) || isboxed)
+    if (isboxed)
         return jl_pvalue_dillvmt;
+    if (jl_is_abstracttype(jt) || jl_is_uniontype(jt) || jl_is_array_type(jt))
+        return jl_pvalue_dillvmt;
+    if (jl_is_typector(jt) || jl_is_typevar(jt))
+        return jl_pvalue_dillvmt;
+    assert(jl_is_datatype(jt));
     jl_datatype_t *jdt = (jl_datatype_t*)jt;
     if (jdt->ditype != NULL) {
 #ifdef LLVM37
@@ -372,6 +377,33 @@ static DIType julia_type_to_di(jl_value_t *jt, DIBuilder *dbuilder, bool isboxed
         return t;
     #endif
     }
+    #ifdef LLVM37
+    else if (jl_is_tuple_type(jt) || jl_is_structtype(jt)) {
+        jl_datatype_t *jst = (jl_datatype_t*)jt;
+        size_t ntypes = jl_datatype_nfields(jst);
+        llvm::DICompositeType *ct = dbuilder->createStructType(
+            NULL,                       // Scope
+            jdt->name->name->name,      // Name
+            NULL,                       // File
+            0,                          // LineNumber
+            8*jdt->size,                // SizeInBits
+            8*jdt->alignment,           // AlignmentInBits
+            0,                          // Flags
+            NULL,                       // DerivedFrom
+            DINodeArray(),              // Elements
+            dwarf::DW_LANG_Julia        // RuntimeLanguage
+            );
+        jdt->ditype = ct;
+        std::vector<llvm::Metadata*> Elements;
+        for(unsigned i = 0; i < ntypes; i++)
+            Elements.push_back(julia_type_to_di(jl_svecref(jst->types,i),dbuilder,false));
+        dbuilder->replaceArrays(ct, dbuilder->getOrCreateArray(ArrayRef<Metadata*>(Elements)));
+        return ct;
+    } else {
+        jdt->ditype = dbuilder->createTypedef(jl_pvalue_dillvmt, jdt->name->name->name, NULL, 0, NULL);
+        return (llvm::DIType*)jdt->ditype;
+    }
+    #endif
     // TODO: Fixme
     return jl_pvalue_dillvmt;
 }
diff --git a/src/codegen.cpp b/src/codegen.cpp
index 20d8127..9693ebd 100644
--- a/src/codegen.cpp
+++ b/src/codegen.cpp
@@ -4715,7 +4715,7 @@ static Function *emit_function(jl_lambda_info_t *lam)
                 topfile,                            // File
                 toplineno == -1 ? 0 : toplineno,  // Line
                 // Variable type
-                julia_type_to_di(varinfo.value.typ,ctx.dbuilder,specsig));
+                julia_type_to_di(varinfo.value.typ,ctx.dbuilder,varinfo.value.isboxed));
 #else
             varinfo.dinfo = ctx.dbuilder->createLocalVariable(
                 llvm::dwarf::DW_TAG_arg_variable,    // Tag
@@ -4723,7 +4723,7 @@ static Function *emit_function(jl_lambda_info_t *lam)
                 argname->name,    // Variable name
                 topfile,                    // File
                 toplineno == -1 ? 0 : toplineno,             // Line (for now, use lineno of the function)
-                julia_type_to_di(varinfo.value.typ, ctx.dbuilder, specsig), // Variable type
+                julia_type_to_di(varinfo.value.typ, ctx.dbuilder,varinfo.value.isboxed), // Variable type
                 false,                  // May be optimized out
                 0,                      // Flags (TODO: Do we need any)
                 ctx.sret + i + 1);                   // Argument number (1-based)
@@ -4737,7 +4737,7 @@ static Function *emit_function(jl_lambda_info_t *lam)
                 ctx.sret + nreq + 1,               // Argument number (1-based)
                 topfile,                    // File
                 toplineno == -1 ? 0 : toplineno,             // Line (for now, use lineno of the function)
-                julia_type_to_di(ctx.vars[ctx.vaName].value.typ, ctx.dbuilder, false));
+                julia_type_to_di(ctx.vars[ctx.vaName].value.typ, ctx.dbuilder, ctx.vars[ctx.vaName].value.isboxed));
 #else
             ctx.vars[ctx.vaName].dinfo = ctx.dbuilder->createLocalVariable(
                 llvm::dwarf::DW_TAG_arg_variable,   // Tag
@@ -4745,7 +4745,7 @@ static Function *emit_function(jl_lambda_info_t *lam)
                 ctx.vaName->name,                   // Variable name
                 topfile,                             // File
                 toplineno == -1 ? 0 : toplineno,  // Line (for now, use lineno of the function)
-                julia_type_to_di(ctx.vars[ctx.vaName].value.typ, ctx.dbuilder, false),      // Variable type
+                julia_type_to_di(ctx.vars[ctx.vaName].value.typ, ctx.dbuilder, ctx.vars[ctx.vaName].value.isboxed),      // Variable type
                 false,                  // May be optimized out
                 0,                      // Flags (TODO: Do we need any)
                 ctx.sret + nreq + 1);              // Argument number (1-based)
@@ -4766,7 +4766,7 @@ static Function *emit_function(jl_lambda_info_t *lam)
                 s->name,                // Variable name
                 topfile,                 // File
                 toplineno == -1 ? 0 : toplineno, // Line (for now, use lineno of the function)
-                julia_type_to_di(varinfo.value.typ, ctx.dbuilder, specsig), // Variable type
+                julia_type_to_di(varinfo.value.typ, ctx.dbuilder, varinfo.value.isboxed), // Variable type
                 false,                  // May be optimized out
                 0                       // Flags (TODO: Do we need any)
 #ifndef LLVM38
@@ -4790,7 +4790,7 @@ static Function *emit_function(jl_lambda_info_t *lam)
                 vname->name,            // Variable name
                 topfile,                 // File
                 toplineno == -1 ? 0 : toplineno, // Line (for now, use lineno of the function)
-                julia_type_to_di(varinfo.value.typ, ctx.dbuilder, specsig), // Variable type
+                julia_type_to_di(varinfo.value.typ, ctx.dbuilder, varinfo.value.isboxed), // Variable type
                 false,                  // May be optimized out
                 0                       // Flags (TODO: Do we need any)
 #ifndef LLVM38
@@ -6106,7 +6106,6 @@ static void init_julia_llvm_env(Module *m)
     FPM->add(createInstructionCombiningPass());  // Clean up after loop vectorizer
 #endif
     //FPM->add(createCFGSimplificationPass());     // Merge & remove BBs
-
     FPM->doInitialization();
 }
 
-- 
2.6.1

